{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/game.js","webpack:///./src/index.js","webpack:///./src/input.js","webpack:///./src/player.js","webpack:///./src/tilemap.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAA4B;;AAE5B;AACA;AACA;AACA;AACe;AACf;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAK;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE;AACA;;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAA0B;AACI;AACE;;AAEhC;AACA,eAAe,6CAAI;;AAEnB;AACA,eAAe,gDAAO;AACtB;AACA,mBAAmB,+CAAM;AACzB;;AAEA;AACA;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,KAAK;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,KAAK;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AAAA;AAAA;AACA;AACA;AACe;AACf;AACA;AACA,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtHA;AAAA;AAAA;AACA;AACA;;AAEe;AACf;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,oBAAoB,mBAAO,CAAC,sDAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","import Input from './input';\n\n/** @class Game\n  * A class representing the high-level functionality\n  * of a game - the game loop, buffer swapping, etc.\n  */\nexport default class Game {\n  /** @constructor\n    * Creates the game instance\n    * @param {integer} width - the width of the game screen in pixels\n    * @param {integer} heght - the height of the game screen in pixels\n    */\n  constructor(width, height) {\n    this._start = null;\n    this.WIDTH = width;\n    this.HEIGHT = height;\n    this.input = new Input();\n    this.map = [];\n    this.entities = [];\n\n    // Set up the back buffer\n    this.backBuffer = document.createElement('canvas');\n    this.backBuffer.width = this.WIDTH;\n    this.backBuffer.height = this.HEIGHT;\n    this.backBufferCtx = this.backBuffer.getContext('2d');\n\n    // Set up the screen buffer\n    this.screenBuffer = document.createElement('canvas');\n    this.screenBuffer.width = this.WIDTH;\n    this.screenBuffer.height = this.HEIGHT;\n    this.screenBufferCtx = this.screenBuffer.getContext('2d');\n    document.body.append(this.screenBuffer);\n  }\n  /** @method addEntity\n    * Adds an entity to the game world\n    * Entities should have an update() and render()\n    * method.\n    * @param {Object} entity - the entity.\n    */\n  addEntity(entity) {\n    this.entities.push(entity);\n  }\n\n  addMap(map) {\n    this.map = map;\n  }\n  /** @method update\n    * Updates the game state\n    * @param {integer} elapsedTime - the number of milliseconds per frame\n    */\n  update(elapsedTime) {\n\n    // Update game entitites\n    this.entities.forEach(entity => entity.update(elapsedTime, this.input,this.map));\n\n    // Swap input buffers\n    this.input.update();\n  }\n  /** @method render\n    * Renders the game state\n    * @param {integer} elapsedTime - the number of milliseconds per frame\n    */\n  render(elapsedTime) {\n    // Clear the back buffer\n    this.backBufferCtx.fillStyle = \"white\";\n    this.backBufferCtx.fillRect(0,0,this.WIDTH, this.HEIGHT);\n\n    // TODO: Render game\n\n    // Render entities\n    this.entities.forEach(entity => entity.render(elapsedTime, this.backBufferCtx));\n\n    // Flip the back buffer\n    this.screenBufferCtx.drawImage(this.backBuffer, 0, 0);\n  }\n  /** @method loop\n    * Updates and renders the game,\n    * and calls itself on the next draw cycle.\n    * @param {DOMHighResTimestamp} timestamp - the current system time\n    */\n  loop(timestamp) {\n    var elapsedTime = this._frame_start ? timestamp - this._frame_start : 0;\n    this.update(elapsedTime);\n    this.render(elapsedTime);\n    this._frame_start = timestamp;\n    window.requestAnimationFrame((timestamp) => {this.loop(timestamp)});\n  }\n}\n","import Game from './game';\nimport Player from './player';\nimport Tilemap from './tilemap';\n\n// Create the game\nvar game = new Game(1024, 768);\n\n// Create the player and add it to the game\nvar tile = new Tilemap(\"untitled\",game.backBufferCtx);\ngame.addEntity(tile);\ngame.addEntity(new Player(60, 60));\ngame.addMap(tile.map);\n\n// Start the main game loop\ngame.loop();\n","\n/** @module Input\n  * A class for handling input from the user\n  * will work for all keys on the keyboard\n  */\nexport default class Input {\n  /** @constructor\n    * Constructs a new instance of the Input class\n    * and attaches event listeners to the window.\n    */\n  constructor() {\n    this.oldState = {}\n    this.newState = {}\n\n    window.addEventListener('keydown', (event) => {\n      event.preventDefault();\n      this.newState[event.key] = true;\n    });\n\n    window.addEventListener('keyup', (event) => {\n      event.preventDefault();\n      this.newState[event.key] = false;\n    });\n\n  }\n\n  /** @method update\n    * Copies the new state to the old state\n    */\n  update() {\n    this.oldState = JSON.parse(JSON.stringify(this.newState));\n  }\n\n  /** @method keyPressed\n    * Returns true if the specified key is\n    * currently pressed.\n    * @param {String} key - the key to test\n    * @return {bool} if the key is pressed\n    */\n  keyPressed(key) {\n    return this.newState[key];\n  }\n\n  /** @method keyDown\n    * Returns true if the specified key\n    * went down this frame\n    * @param {String} key - the key to test\n    * @return {bool} if the key is pressed\n    */\n  keyDown(key) {\n    return this.newState[key] && !this.oldState[key];\n  }\n\n  /** @method keyUp\n    * Returns true if the specified key\n    * went up this frame\n    * @param {String} key - the key to test\n    * @return {bool} if the key is pressed\n    */\n  keyUp(key) {\n    return !this.newState[key] && this.oldState[key];\n  }\n}\n","/** @module Player\n  * A class representing the player.\n  */\nexport default class Player {\n  /** @constructor\n    * Constructs a new player instance\n    * @param {float} x - the player's x position\n    * @param {float} y - the player's y position\n    */\n  constructor(x, y) {\n      this.x = x;\n      this.y = y;\n      this.radius = 32;\n      this.up = true;\n      this.down = false;\n      this.left = false;\n      this.right = false;\n      this.mov = 0;\n      this.time = 0;\n      this.sprite = new Image(32, 32);\n      this.sprite.src = \"./sprite/Character.png\";\n  }\n\n  makeMove() {\n    if(this.time > 200) {\n        this.mov = (this.mov + 32) % 128;\n        this.time = 0;\n    }\n  }\n\n  resetMove(){\n    this.mov = 0;\n  }\n\n  /** @method update\n    * Updates the player\n    * @param {double} deltaT - the elapsed time\n    * @param {Input} input - the input object\n    */\n  update(deltaT, input, map) {\n    this.time += deltaT;\n    var x_map = Math.ceil((this.x + 25) / 32) - 1;\n    var y_map = Math.ceil((this.y + 25) / 32) - 1;\n    if(input.keyPressed(\"ArrowLeft\") && !map[Math.ceil((this.x - 1) / 32) - 1][y_map]) {\n        this.x--;\n        if(this.left)\n          this.makeMove();\n        else\n          this.resetMove();\n        this.left = true;\n        this.up = false;\n        this.down = false;\n        this.right = false;\n        if (this.x < 3)\n            this.x = 3;\n    }\n    else if(input.keyPressed(\"ArrowRight\")  && !map[Math.ceil((this.x + 1 + this.radius) / 32) - 1][y_map]) {\n        this.x++;\n        if(this.right)\n            this.makeMove();\n        else\n            this.resetMove();\n        this.right = true;\n        this.up = false;\n        this.down = false;\n        this.left = false;\n        if (this.x + this.radius > 1024)\n            this.x = 1023 - this.radius;\n    }\n    else if(input.keyPressed(\"ArrowUp\")  && !map[x_map][Math.ceil((this.y - 1) / 32) - 1]) {\n        this.y--;\n        if(this.up)\n            this.makeMove();\n        else\n            this.resetMove();\n        this.up = true;\n        this.down = false;\n        this.left = false;\n        this.right = false;\n        if (this.y < 3)\n            this.y = 3;\n    }\n    else if(input.keyPressed(\"ArrowDown\") && !map[x_map][Math.ceil((this.y + 1 + this.radius) / 32) - 1]) {\n        this.y++;\n        if(this.down)\n            this.makeMove();\n        else\n            this.resetMove();\n        this.down = true;\n        this.up = false;\n        this.left = false;\n        this.right = false;\n        if (this.y + this.radius > 765)\n            this.y = 768 - this.radius;\n    }\n  }\n\n  /** @method render\n    * Renders the player\n    * @param {double} deltaT - elapsed time\n    * @param {Context2D} context - the rendering context\n    */\n  render(deltaT, context) {\n      if (this.up) {\n          context.drawImage(this.sprite, 32, this.mov, 32, 32,\n              this.x, this.y, 32, 32);\n      } else if (this.down) {\n          context.drawImage(this.sprite, 0, this.mov, 32, 32,\n              this.x, this.y, 32, 32);\n      } else if (this.left) {\n          context.drawImage(this.sprite, 96, this.mov, 32, 32,\n              this.x, this.y, 32, 32);\n      } else if (this.right) {\n          context.drawImage(this.sprite, 64, this.mov, 32, 32,\n              this.x, this.y, 32, 32);\n      }\n  }\n\n}\n","/** @module Tilemap\r\n * A class representing the player.\r\n */\r\n\r\nexport default class Tilemap {\r\n    /** @constructor\r\n     * Constructs a new player instance\r\n     * @param {float} x - the player's x position\r\n     * @param {float} y - the player's y position\r\n     */\r\n    constructor(name,canvas) {\r\n        this.name = name;\r\n        this.layers = [];\r\n        this.data = [];\r\n        this.c = canvas;\r\n        this.map = new Array(33);\r\n\r\n        for (var i = 0; i < 33; i++) {\r\n            this.map[i] = new Array(2);\r\n            for(var j = 0; j < 25; j++) {\r\n                if (j == 25) {\r\n                    this.map[i][j] = 1;\r\n                } else\r\n                    this.map[i][j] = 0;\r\n            }\r\n        }\r\n        this.loadTileset();\r\n    }\r\n\r\n    renderLayer() {\r\n        // data: [array of tiles, 1-based, position of sprite from top-left]\r\n        // height: integer, height in number of sprites\r\n        // name: \"string\", internal name of layer\r\n        // opacity: integer\r\n        // type: \"string\", layer type (tile, object)\r\n        // visible: boolean\r\n        // width: integer, width in number of sprites\r\n        // x: integer, starting x position\r\n        // y: integer, starting y position\r\n        var size = this.data.tilewidth;\r\n        let _this = this;\r\n        let x = 0;\r\n        let y = 0\r\n        for(var j = 0; j < 2; j++) {\r\n            let layer = this.data.layers[j];\r\n            layer.data.forEach(function(tile_idx, i) {\r\n                x = (i % layer.width);\r\n                y = ~~(i / layer.width);\r\n                if (!tile_idx) { return; }\r\n                if(j == 1) {\r\n                    _this.map[x][y] = 1;\r\n                }\r\n                var img_x, img_y, s_x, s_y,\r\n                    tile = _this.data.tilesets[0];\r\n                tile_idx--;\r\n                img_x = (tile_idx % (tile.imagewidth / size)) * size;\r\n                img_y = ~~(tile_idx / (tile.imagewidth / size)) * size;\r\n                s_x = x * size;\r\n                s_y = y * size;\r\n                _this.c.drawImage(_this.tileset, img_x, img_y, size, size,\r\n                    s_x, s_y, size, size);\r\n            });\r\n        }\r\n    }\r\n\r\n    loadTileset() {\r\n        this.data = require('./maps/untitled.json');\r\n        this.tileset = new Image(1024,768);\r\n        this.tileset.src = \".\" + this.data.tilesets[0].image;\r\n        this.renderLayer();\r\n    }\r\n    render(deltaT, contex){\r\n        this.renderLayer();\r\n    }\r\n    update(deltaT, input) {\r\n\r\n    }\r\n\r\n}\r\n"],"sourceRoot":""}